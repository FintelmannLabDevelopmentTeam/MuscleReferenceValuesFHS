require(tidyverse)
source('read_data/read_filter_assessed_df.R')
#Gather data together

#Load data from main QA run.
assessed_path_first_run <- 'Path/To/All/Segmentation/Results'
assessed_df_first_run <- read_filter_assessed_df(assessed_path_first_run)

#Load data from Inter-/Intrarater Agreement runs
assessed_path_PET <- 'Path/To/Results/QAd/by/PET'
assessed_df_PET <- read_filter_assessed_df(assessed_path_PET)

assessed_path_ASD <- 'Path/To/Results/QAd/by/ASD'
assessed_df_ASD <- read_filter_assessed_df(assessed_path_ASD)

mark_exclusion_editing <- function(assessed_df){
  #' Mark which segmentations were flagged for exclusion, and which were edited (level selection or segmentation).
  #'
  #' @param assessed_df data.frame The dataframe generated by QA of the segmentation results.
  #' 
  #' @return The dataframe with additional logical columns edited, segmentation_edited, and level_selection_edited
  
  muscle_exclusion_questions <- c('incomplete_muscle_fov', 'level_unavailable', 
                                  'segmentation_impossible',
                                  'lowdose',
                                  'artifacts',
                                  'edema',
                                  'arms_down_unremovable',
                                  'touching_gantry',
                                  'reconstruction_filter',
                                  'phantom_unremovable')
  
  #Create column 'excluded' and default it to FALSE. Create empty column with reasons for exclusion.
  assessed_df$excluded=FALSE
  assessed_df$exclusion_reasons=''
  
  #Loop over questions leading to exclusion, if answered as 'yes'. 
  #Set excluded to TRUE if any of the questions were answered as 'yes' in a given row and log reasons separated by , as string.
  for(question in muscle_exclusion_questions){
    q <- paste(question, '_yes', sep= '')
    assessed_df<-assessed_df %>% 
      mutate(excluded=ifelse(.data[[q]], TRUE, excluded)) %>% 
      mutate(exclusion_reasons=ifelse(.data[[q]], paste(exclusion_reasons, question, sep=', '), exclusion_reasons))
  }
  #Summarize different editation columns.
  assessed_df <- assessed_df%>%
    mutate(edited = level_selection_edited_yes | segmentation_edited_yes, segmentation_edited = segmentation_edited_yes, level_selection_edited = level_selection_edited_yes)
  return(assessed_df)
  }

filter_df <- function(df){
  #' Reduce dataframe to columns relevant for assessment of ICC and Cohen's kappa
  #' 
  #' @param df data.frame The dataframe.
  #' 
  #' @return The slim dataframe.
  df <- df%>%select(ID,
                    IDTYPE,
                    series_UID,
                    vertebral_level,
                    excluded,
                    edited,
                    muscle_area_cm2,
                    muscle_mean_hu)
    
  return(df)
}

#Filter all dataframes into slimmer versions
assessed_df_first_run <- filter_df(mark_exclusion_editing(assessed_df_first_run))
assessed_df_ASD <- filter_df(mark_exclusion_editing(assessed_df_ASD))
assessed_df_PET <- filter_df(mark_exclusion_editing(assessed_df_PET))



#ICC:
#https://www.datanovia.com/en/lessons/intraclass-correlation-coefficient-in-r/#:~:text=The%20Intraclass%20Correlation%20Coefficient%20(ICC,with%20two%20or%20more%20raters.
#see Best et al. 2020


#package for ICC: irr
require('irr')


#McNemar:
#https://www.statology.org/mcnemars-test-r/

########ICC: Regarding muscle area and SMRA measurements
####Intrareader Reliability:

#PET originally checked all segmentations of L3 and T5, and ASD all segmentations at T10 and T8. Hence, for intrareader agreement, need to compare re-evaluations at those levels, respectively.
intrareader_frame_second_run_PET <- assessed_df_PET %>% filter(vertebral_level=='L3' | vertebral_level == 'T5')
intrareader_frame_second_run_ASD <- assessed_df_ASD %>% filter(vertebral_level=='T10' | vertebral_level == 'T8')

#Create dataframes: join initial measurements with re-evaluations, for each raters individually and for both raters combined.
intrareader_frame_second_run <- intrareader_frame_second_run_PET %>%
  rbind(intrareader_frame_second_run_ASD) 

intrareader_frame <- assessed_df_first_run %>% 
  inner_join(intrareader_frame_second_run, by=c('ID', 'IDTYPE', 'series_UID', 'vertebral_level'),
suffix=c('_1', '_2')) 

intrareader_frame_ASD <- assessed_df_first_run %>% 
  inner_join(intrareader_frame_second_run_ASD, by=c('ID', 'IDTYPE', 'series_UID', 'vertebral_level'),
             suffix=c('_1', '_2')) 
intrareader_frame_PET <- assessed_df_first_run %>% 
  inner_join(intrareader_frame_second_run_PET, by=c('ID', 'IDTYPE', 'series_UID', 'vertebral_level'),
             suffix=c('_1', '_2')) 

#Only assess ICC in cases that were not excluded by either QA run.
intrareader_frame_ICC <- intrareader_frame %>%
  filter(!excluded_1 & !excluded_2) 
intrareader_frame_PET_ICC <- intrareader_frame_PET %>% filter(!excluded_1 & !excluded_2)
intrareader_frame_ASD_ICC <- intrareader_frame_PET %>% filter(!excluded_1 & !excluded_2)


#Create dataframes with one column holding area measurements from the first QA run, and the second column holding area measurements from the second QA run.
icc_SMA_intrareader <- intrareader_frame_ICC %>% select(contains('muscle_area'))

icc_SMA_intrareader_ASD <- intrareader_frame_ASD_ICC %>% select(contains('muscle_area'))
icc_SMA_intrareader_PET <- intrareader_frame_PET_ICC %>% select(contains('muscle_area'))

  

#Intrareader PET on area measurements:
irr::icc(icc_SMA_intrareader_PET,  model = "twoway", 
         type = "agreement", unit = "single"
)

#Intrareader ASD on area measurements:
irr::icc(icc_SMA_intrareader_ASD,  model = "twoway", 
         type = "agreement", unit = "single"
)


#####Interreader Reliability:
###ICC

#Conversely, now inspects second measurements from ASD on L3 and T5 and PET on T10 and T8.
interreader_frame_second_run <- assessed_df_ASD %>% filter(vertebral_level=='L3' | vertebral_level == 'T5') %>%
  rbind(assessed_df_PET %>% filter(vertebral_level=='T10' | vertebral_level == 'T8')) 

#Merge sheets from first and second QA.
interreader_frame <- assessed_df_first_run %>% 
  inner_join(interreader_frame_second_run, by=c('ID', 'IDTYPE', 'series_UID', 'vertebral_level'),
             suffix=c('_1', '_2')) 
#Exclude cases from ICC calculation, that were chosen to be excluded during either QA run.
interreader_frame_ICC <- interreader_frame %>%
  filter(!excluded_1 & !excluded_2)

#Interreader ICC Muscle Area only
interreader_ICC_SMA_frame <- interreader_frame_ICC %>% select(contains('muscle_area'))

irr::icc(interreader_ICC_SMA_frame,
        model = "twoway", 
        type = "agreement", unit = "single"
)


########### McNemar: Assess Agreement for exclusion/inclusion.
#############

create_mcnemar_matrix <- function(mcnemar_df){
  #' Create matrix based on excluded_1 and 2 column of a dataframe.
  #' It will hold times of agreement and disagreement in contingency table.
  #' 
  #' @return that matrix.
  mcnemar_df <- mcnemar_df %>% select(excluded_1, excluded_2)
  both_include <- sum(!mcnemar_df$excluded_1 & !mcnemar_df$excluded_2)
  one_includes_2_excludes <- sum(!mcnemar_df$excluded_1 & mcnemar_df$excluded_2)
  two_includes_1_excludes <- sum(mcnemar_df$excluded_1 & !mcnemar_df$excluded_2)
  both_exclude <- sum(mcnemar_df$excluded_1 & mcnemar_df$excluded_2)
  
  
  mcnemar_matrix <- matrix(
    c(both_include, two_includes_1_excludes,
      one_includes_2_excludes, both_exclude),
    nrow=2,
    dimnames = list('First' = c('Included', 'Excluded'),
                    'Second' = c('Included', 'Excluded'))
  )
  
  return(mcnemar_matrix)
}

#Intrareader Agreement McNemar & Cohen's Kappa
########
intrareader_mcnemar_matrix <- create_mcnemar_matrix(intrareader_frame)
intrareader_mcnemar_matrix

mcnemar.test(intrareader_mcnemar_matrix, correct=TRUE)

irr::kappa2(intrareader_frame[, c('excluded_1', 'excluded_2')])

#For ASD:
intrareader_mcnemar_matrix_ASD <- create_mcnemar_matrix(intrareader_frame_ASD)
intrareader_mcnemar_matrix_ASD

mcnemar.test(intrareader_mcnemar_matrix_ASD, correct=T)

irr::kappa2(intrareader_frame_ASD[, c('excluded_1', 'excluded_2')])


#For PET:
intrareader_mcnemar_matrix_PET <- create_mcnemar_matrix(intrareader_frame_PET)
intrareader_mcnemar_matrix_PET

mcnemar.test(intrareader_mcnemar_matrix_PET, correct=T)

irr::kappa2(intrareader_frame_PET[, c('excluded_1', 'excluded_2')])

#Interreader Agreement McNemar & Cohen's Kappa
interreader_mcnemar_matrix <- create_mcnemar_matrix(interreader_frame)
interreader_mcnemar_matrix

mcnemar.test(interreader_mcnemar_matrix, correct = T)

irr::kappa2(interreader_frame[, c('excluded_1', 'excluded_2')])


